<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>SVG ì²´ìŠ¤ ê²Œì„ - ì²´í¬ ê°ì§€ í¬í•¨</title>
  <style>
  body {
  margin: 0;
  background: #f0f0f0;
  font-family: 'Arial', sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
    .chess-board {
      position: relative; /* ì¶”ê°€ */
      display: grid;
      grid-template-columns: repeat(8, 80px);
      grid-template-rows: repeat(8, 80px);
      border: 4px solid #222;
    }
    .cell {
      width: 80px;
      height: 80px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      transition: background 0.3s;
    }
    .white { background: #eeeed2; }
    .black { background: #769656; }
    .selected { outline: 3px solid red; }
    .highlight::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      background: rgba(255, 0, 0, 0.6);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .check::after {
      content: '';
      position: absolute;
      inset: 4px;
      border: 3px solid red;
      border-radius: 4px;
    }
    .piece {
      width: 80%;
      height: 80%;
      transition: transform 0.3s;
    }
    .moving {
      transform: scale(1.2);
    }
    .player-info {
  width: 640px;
  padding: 10px 15px;
  margin: 10px auto;
  background: #ffffff;
  border: 2px solid #333;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  font-size: 18px;
  font-family: 'Arial', sans-serif;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.15);
}

.player-info.top {
  margin-bottom: 5px;
}

.player-info.bottom {
  margin-top: 5px;
}

.player-info .nickname {
  font-weight: bold;
}

.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.chess-board {
  display: grid;
  grid-template-columns: repeat(8, 80px);
  grid-template-rows: repeat(8, 80px);
  border: 4px solid #222;
}

.player-info {
  width: 640px;
  padding: 10px 15px;
  background: #ffffff;
  border: 2px solid #333;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  font-size: 18px;
  margin: 10px 0;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.15);
}

.player-info.active {
  background: #f0f8ff;
  border-color: #0077cc;
}
  </style>
</head>
<body>


  <div style="position: absolute; top: 20px; text-align: center; font-size: 24px;">
  í˜„ì¬ í„´: <span id="turn-indicator">í°ìƒ‰</span>
</div>
<div style="position: absolute; top: 60px; text-align: center; font-size: 20px;">
  ë‹¹ì‹ ì€ <span id="player-color-label">ë¡œë”© ì¤‘...</span> í”Œë ˆì´ì–´ì…ë‹ˆë‹¤.
</div>
  <div id="promotion-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
  background:white; border:2px solid #333; padding:20px; z-index:9999; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.5); border-radius:8px;">

 <p>ìŠ¹ê¸‰í•  ê¸°ë¬¼ì„ ì„ íƒí•˜ì„¸ìš”:</p>
  <button onclick="promote('q')">â™› í€¸</button>
  <button onclick="promote('r')">â™œ ë£©</button>
  <button onclick="promote('b')">â™ ë¹„ìˆ</button>
  <button onclick="promote('n')">â™ ë‚˜ì´íŠ¸</button>
</div>

 <div class="game-container">
    <div id="black-info" class="player-info top"></div>

    <div id="board" class="chess-board"></div>

    <div id="white-info" class="player-info bottom"></div>
  </div>



  <script type="module">
  // Firebase SDK ë¶ˆëŸ¬ì˜¤ê¸°
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
  import { getDatabase, ref, onValue, set, get, update } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
import { setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { child } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";


    const firebaseConfig = {
      apiKey: "AIzaSyCkH8VYctflhZQh5_g_QQ2X9B-dt8h_uSA",
      authDomain: "chessstrock.firebaseapp.com",
      projectId: "chessstrock",
      storageBucket: "chessstrock.firebasestorage.app",
      messagingSenderId: "1041655877297",
      appId: "1:1041655877297:web:d35e9b5838ea2fcc5a1c90",
      measurementId: "G-6JCL5Z363K"
    };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

const urlParams = new URLSearchParams(window.location.search);
const matchId = urlParams.get('matchId');  // default_match ì œê±°!
if (!matchId) {
  alert("matchIdê°€ URLì— ì—†ìŠµë‹ˆë‹¤. main.htmlì—ì„œ ì •ìƒì ìœ¼ë¡œ ë“¤ì–´ì˜¤ì„¸ìš”.");
  window.location.href = "main.html";
}
console.log("ğŸ¯ í˜„ì¬ matchId:", matchId);
const gameRef = ref(db, `games/${matchId}`);


const auth = getAuth();
setPersistence(auth, browserLocalPersistence);

let myColor = null;
  let myUid = null; 

onAuthStateChanged(auth, user => {
  if (user) {
   myUid = user.uid;
    console.log("ğŸ”¥ ë¡œê·¸ì¸ëœ ì‚¬ìš©ì:", user.email || user.uid);
 // ğŸ‘ˆ í˜„ì¬ ì‚¬ìš©ì uid ì €ì¥
    
    init(); // âœ… ë¡œê·¸ì¸ í›„ì— ê²Œì„ ì´ˆê¸°í™”
  } else {
    alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. ë©”ì¸ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.");
    window.location.href = "index.html";
  }
});




    const svgMap = {
      'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
      'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
      'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
      'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
      'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
      'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
      'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
      'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
      'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
      'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
      'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
      'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg'
    };

    const initial = [
      "rnbqkbnr",
      "pppppppp",
      "........",
      "........",
      "........",
      "........",
      "PPPPPPPP",
      "RNBQKBNR"
    ];

let hasMoved = {
  'K_white': false,
  'R_white_a': false, // ì™¼ìª½ ë£© (a1)
  'R_white_h': false, // ì˜¤ë¥¸ìª½ ë£© (h1)
  'K_black': false,
  'R_black_a': false, // a8
  'R_black_h': false  // h8
};

    let enPassantTarget = null; // ì•™íŒŒìƒ íƒ€ê²Ÿ ì¹¸: [row, col] ë˜ëŠ” null

    let board = [];
    let turn = 'white';
    let selected = null;
    const boardElement = document.getElementById('board');



onValue(gameRef, (snapshot) => {
  if (isLocalChange) {
    isLocalChange = false;
    return;
  }
  const data = snapshot.val();
  if (data) {
    board = data.board.map(row => row.split(''));
    turn = data.turn;
    whitePlayerId = data.whitePlayerId || null;
    blackPlayerId = data.blackPlayerId || null;

        // ğŸ” ì—¬ê¸°ì„œ ë¡œê·¸ ì¶”ê°€
    console.log("ğŸ“¦ Firebaseë¡œë¶€í„° ë°›ì€ game ìƒíƒœ:");
    console.log("âšª whitePlayerId:", whitePlayerId);
    console.log("âš« blackPlayerId:", blackPlayerId);
    console.log("ğŸ® í˜„ì¬ í„´:", turn);
    updatePlayerInfoUI();  // âœ… ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”
    drawBoard();
  }
});


    function isWhite(ch) {
      return ch >= 'A' && ch <= 'Z';
    }

    function findKing(isW) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (!board[r]) continue;
          const ch = board[r][c];
          if ((isW && ch === 'K') || (!isW && ch === 'k')) return [r, c];
        }
      }
      return null;
    }

    function isCheck(isW) {
      const kingPos = findKing(isW);
      if (!kingPos) return false;
      const [kr, kc] = kingPos;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (!board[r]) continue;
          const ch = board[r][c];
          if (ch !== '.' && isWhite(ch) !== isW) {
            const moves = getBasicMoves(r, c);
            if (moves.some(([mr, mc]) => mr === kr && mc === kc)) return true;
          }
        }
      }
      return false;
    }

  function drawBoard(myUid) {
      boardElement.innerHTML = '';
      let highlights = [];
        if (!Array.isArray(board) || board.length !== 8 || board.some(row => row.length !== 8)) {
    console.warn("â›” drawBoard í˜¸ì¶œ ì‹œ boardê°€ ì˜ëª»ëœ ìƒíƒœ:", board);
    return;
  }
      if (selected) {
        const [sRow, sCol] = selected;
        highlights = getLegalMoves(sRow, sCol);
      }
      const checkKing = findKing(turn === 'white');
      const inCheck = isCheck(turn === 'white');
const isFlipped = (myColor === 'black'); // OK

for (let i = 0; i < 8; i++) {
  const row = isFlipped ? 7 - i : i;
  for (let j = 0; j < 8; j++) {
    const col = isFlipped ? 7 - j : j;
          const cell = document.createElement('div');
          const piece = board[row][col];
          cell.className = `cell ${(row + col) % 2 ? 'black' : 'white'}`;
          cell.dataset.row = row;
          cell.dataset.col = col;

          if (selected && selected[0] === row && selected[1] === col) {
            cell.classList.add('selected');
          }

         if (highlights.some(pos => pos[0] === row && pos[1] === col)) {
  cell.classList.add('highlight');
}


          if (inCheck && checkKing && row === checkKing[0] && col === checkKing[1]) {
            cell.classList.add('check');
          }

          if (piece !== '.') {
            const img = document.createElement('img');
            img.className = 'piece';
            img.src = svgMap[piece];
            cell.appendChild(img);
          }
          

          cell.addEventListener('click', handleClick);
          boardElement.appendChild(cell);
         document.getElementById("player-color-label").innerText =
  myColor === "white" ? "í°ìƒ‰" : "ê²€ì€ìƒ‰";
document.getElementById('turn-indicator').style.color = (turn === 'white') ? 'black' : 'darkred';
document.getElementById("turn-indicator").innerText = (turn === 'white') ? 'í°ìƒ‰' : 'ê²€ì€ìƒ‰';
document.getElementById("turn-indicator").style.color = (turn === 'white') ? 'black' : 'darkred';

        }
      }
    }
    function updatePlayerInfoUI() {
  const whiteBox = document.getElementById("white-info");
  const blackBox = document.getElementById("black-info");

  const isWhiteTurn = (turn === "white");

  whiteBox.innerHTML = `
    <span class="nickname">ğŸ– ${whitePlayerId?.nickname || "ë°± í”Œë ˆì´ì–´"}</span>
    <span class="team">ğŸ›¡ ${whitePlayerId?.team || "íŒ€ ì—†ìŒ"}</span>
  `;

  blackBox.innerHTML = `
    <span class="nickname">ğŸ– ${blackPlayerId?.nickname || "í‘ í”Œë ˆì´ì–´"}</span>
    <span class="team">ğŸ›¡ ${blackPlayerId?.team || "íŒ€ ì—†ìŒ"}</span>
  `;

  whiteBox.classList.toggle("active", isWhiteTurn);
  blackBox.classList.toggle("active", !isWhiteTurn);
}


    let pendingPromotion = null; // { row, col, isWhite, callback }

function showPromotionModal(row, col, isW, callback) {

  pendingPromotion = { row, col, isWhite: isW, callback };
  document.getElementById('promotion-modal').style.display = 'block';
}



function handleClick(e) {

        const uid = auth.currentUser?.uid;
const isMyTurn =
  (turn === 'white' && uid === whitePlayerId?.uid) ||
  (turn === 'black' && uid === blackPlayerId?.uid);
console.log("ğŸ¯ í´ë¦­ ë°œìƒ!");
console.log("ğŸ§© í˜„ì¬ ì‚¬ìš©ì uid:", uid);
console.log("âšª whitePlayerId:", whitePlayerId);
console.log("âš« blackPlayerId:", blackPlayerId);
console.log("ğŸ® í˜„ì¬ í„´:", turn);
console.log("ğŸ•¹ï¸ isMyTurn ê³„ì‚° ê²°ê³¼:", isMyTurn);
// handleClick í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì¶”ê°€
if (!isMyTurn) {
  alert("ë‹¹ì‹ ì˜ ì°¨ë¡€ê°€ ì•„ë‹™ë‹ˆë‹¤!");
  return;
}

function promote(piece) {
  const { row, col, isWhite, callback } = pendingPromotion;
  board[row][col] = isWhite ? piece.toUpperCase() : piece;
  document.getElementById('promotion-modal').style.display = 'none';
  pendingPromotion = null;

  // í„´ ë³€ê²½ ë° ì €ì¥
  turn = (turn === 'white') ? 'black' : 'white';
  isLocalChange = true;
  saveGameState();
  drawBoard();

  // ìŠ¹ê¸‰ í›„ ì²´í¬ë©”ì´íŠ¸ ì—¬ë¶€ ì½œë°± ì²˜ë¦¬ (ì½œë°± ë‚´ë¶€ì— í„´ ë³€ê²½ ì—†ì–´ì•¼ í•¨)
  if (typeof callback === 'function') {
    callback();
  }
}

window.promote = promote;

  const row = parseInt(e.currentTarget.dataset.row);
  const col = parseInt(e.currentTarget.dataset.col);
  const piece = board[row][col];
const isOwn = myColor === 'white' ? isWhite(piece) : (!isWhite(piece) && piece !== '.');

  if (selected) {
    const [sRow, sCol] = selected;
    const moves = getLegalMoves(sRow, sCol);
    if (moves.some(([r, c]) => r === row && c === col)) {
      const temp = JSON.parse(JSON.stringify(board));

      // ìºìŠ¬ë§ ì²˜ë¦¬
      const selectedPiece = board[sRow][sCol];
      const isW = isWhite(selectedPiece);

      // ê¸°ë³¸ ì´ë™
      board[row][col] = selectedPiece;
      board[sRow][sCol] = '.';

      // ìºìŠ¬ë§ ì¡°ê±´: í‚¹ì´ ë‘ ì¹¸ ì´ë™í–ˆì„ ë•Œ ë£©ë„ ê°™ì´ ì›€ì§ì„
      if (selectedPiece.toLowerCase() === 'k' && Math.abs(col - sCol) === 2) {
        if (col === 6) { // í‚¹ì‚¬ì´ë“œ ìºìŠ¬ë§
          board[row][5] = board[row][7];
          board[row][7] = '.';
          // hasMoved ì—…ë°ì´íŠ¸ (ë£©)
          if (isW) hasMoved['R_white_h'] = true;
          else hasMoved['R_black_h'] = true;
        } else if (col === 2) { // í€¸ì‚¬ì´ë“œ ìºìŠ¬ë§
          board[row][3] = board[row][0];
          board[row][0] = '.';
          // hasMoved ì—…ë°ì´íŠ¸ (ë£©)
          if (isW) hasMoved['R_white_a'] = true;
          else hasMoved['R_black_a'] = true;
        }
      }



      // hasMoved ì—…ë°ì´íŠ¸ (í‚¹, ë£© ì´ë™ ê¸°ë¡)
      if (selectedPiece.toLowerCase() === 'k') {
        if (isW) hasMoved['K_white'] = true;
        else hasMoved['K_black'] = true;
      }
      if (selectedPiece.toLowerCase() === 'r') {
        if (isW) {
          if (sRow === 7 && sCol === 0) hasMoved['R_white_a'] = true;
          else if (sRow === 7 && sCol === 7) hasMoved['R_white_h'] = true;
        } else {
          if (sRow === 0 && sCol === 0) hasMoved['R_black_a'] = true;
          else if (sRow === 0 && sCol === 7) hasMoved['R_black_h'] = true;
        }


if (selectedPiece.toLowerCase() === 'p' && Math.abs(row - sRow) === 2) {
  // ë‘ ì¹¸ ì „ì§„í•œ í°ì˜ ë°”ë¡œ ì¤‘ê°„ ì¹¸ì„ enPassantTargetìœ¼ë¡œ ì„¤ì •
  enPassantTarget = [(row + sRow) / 2, col];
} else {
  enPassantTarget = null; // ê·¸ ì™¸ëŠ” ì´ˆê¸°í™”
}
      }
      // ì•™íŒŒìƒ ì²˜ë¦¬: í°ì´ ëŒ€ê°ì„  ì´ë™í–ˆê³  ì´ë™ ì¹¸ì´ ë¹ˆì¹¸ì¼ ê²½ìš°
// ì´ë™ ì „ì— í°ì´ ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™í–ˆëŠ”ì§€, ê·¸ë¦¬ê³  ì´ë™ ëª©ì ì§€ê°€ ë¹ˆ ì¹¸ì¸ì§€ íŒë‹¨ (ì•™íŒŒìƒ ì¡°ê±´)
if (selectedPiece.toLowerCase() === 'p' && col !== sCol) {
  // ì´ë™ ì „ì— ë¹ˆ ì¹¸ì¸ì§€ í™•ì¸(ì´ë™ í›„ì—ëŠ” ì´ë¯¸ í°ì´ ì˜¬ë¼ê°)
  // enPassantTargetê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•˜ê±°ë‚˜, ì•„ë˜ì²˜ëŸ¼ íŒë‹¨ ê°€ëŠ¥
  if (enPassantTarget && row === enPassantTarget[0] && col === enPassantTarget[1]) {
    const dir = isWhite(selectedPiece) ? -1 : 1;
    const capturedRow = row - dir;
    const capturedCol = col;
    board[capturedRow][capturedCol] = '.'; // ì¡íŒ í° ì‚­ì œ
  }
}


      // ì´ë™ í›„ ì²´í¬ì¸ì§€ í™•ì¸
// ì´ë™ í›„ ì²´í¬ì¸ì§€ í™•ì¸
if (isCheck(isWhite(selectedPiece))) {
  // ìƒëŒ€ë°© í„´ ì²´í¬ë©”ì´íŠ¸ ê²€ì‚¬
  const nextTurn = turn === 'white' ? 'black' : 'white';
  if (isCheckMate(nextTurn)) {
    // ì²´í¬ë©”ì´íŠ¸ë©´ ì´ë™ ì¸ì • (ê²Œì„ ì¢…ë£Œ)
    animateMove(sRow, sCol, row, col, () => {
      alert(`ì²´í¬ë©”ì´íŠ¸! ${nextTurn === 'white' ? 'í°ìƒ‰' : 'ê²€ì€ìƒ‰'} íŒ¨ë°°`);
      // í•„ìš”ì‹œ ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬ ì¶”ê°€
      turn = nextTurn;
      drawBoard();
    });
    return;
  } else {
    // ì²´í¬ ìƒíƒœë©´ ì´ë™ ë¬´íš¨
    board = temp;
    alert('ìì‹ ì´ ì²´í¬ ìƒíƒœê°€ ë˜ëŠ” ìˆ˜ëŠ” ë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    selected = null;
    
    return;
  }
} else {
// drawBoard()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì§€ ì•Šê³  animateMove í›„ì—ë§Œ í˜¸ì¶œ
animateMove(sRow, sCol, row, col, () => {
  const promoted = board[row][col];
  if (promoted.toLowerCase() === 'p' && (row === 0 || row === 7)) {
showPromotionModal(row, col, isWhite(promoted), () => {
  // ìŠ¹ê¸‰ í›„ í„´ ë³€ê²½ê³¼ ì €ì¥ì€ promote í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì—¬ê¸°ì„  í•˜ì§€ ë§ ê²ƒ
  if (isCheckMate(turn === 'white')) {
    alert(`ì²´í¬ë©”ì´íŠ¸! ${turn === 'white' ? 'í°ìƒ‰' : 'ê²€ì€ìƒ‰'} íŒ¨ë°°`);
  }
  // drawBoard()ëŠ” ì´ë¯¸ promoteì—ì„œ í˜¸ì¶œë¨
});
    return;
  }

turn = turn === 'white' ? 'black' : 'white';
saveGameState();
  if (isCheckMate(turn === 'white')) {
    alert(`ì²´í¬ë©”ì´íŠ¸! ${turn === 'white' ? 'í°ìƒ‰' : 'ê²€ì€ìƒ‰'} íŒ¨ë°°`);
  }
  drawBoard(); // ì¼ë°˜ ì´ë™ í›„ drawBoard
});
}


      selected = null;
    } else if (isOwn) {
      selected = [row, col];
    } else {
      selected = null;
    }
  } else if (isOwn) {
    selected = [row, col];
  }
  drawBoard();
}


let isLocalChange = false;

function saveGameState() {
  const user = auth.currentUser;
  if (!user) {
    console.warn("ì•„ì§ ë¡œê·¸ì¸ë˜ì§€ ì•ŠìŒ. ì €ì¥ ì•ˆ í•¨.");
    return;
  }

  isLocalChange = true;

  // ê¸°ì¡´ whitePlayerId, blackPlayerIdë¥¼ ë³´ì¡´í•˜ë©´ì„œ boardì™€ turnë§Œ ì—…ë°ì´íŠ¸
  update(gameRef, {
    board: board.map(row => row.join('')),
    turn: turn
  });
}




function getBasicMoves(r, c) {
  const piece = board[r][c];
  if (!piece || piece === '.') return [];
  const isW = isWhite(piece);
  const moves = [];

  // ì—°ì† ì´ë™ì´ ê°€ëŠ¥í•œ ê¸°ë¬¼ë“¤ì„ ìœ„í•œ push í•¨ìˆ˜
  const pushSlide = (dr, dc) => {
    for (let i = 1; i < 8; i++) {
      const nr = r + dr * i;
      const nc = c + dc * i;
      if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
      const target = board[nr][nc];
      if (target === '.') {
        moves.push([nr, nc]);
      } else {
        if (isWhite(target) !== isW) moves.push([nr, nc]);
        break; // ë§‰í˜
      }
    }
  };

  // ë‹¨ì¼ ì¹¸ ì´ë™ìš©
  const push = (nr, nc) => {
    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
      const target = board[nr][nc];
      if (target === '.' || isWhite(target) !== isW) moves.push([nr, nc]);
    }
  };

  const dir = isW ? -1 : 1;

  switch (piece.toLowerCase()) {
    case 'p':
      const front = r + dir;
      // ì• ì¹¸ì´ ë¹„ì–´ìˆì–´ì•¼ ì´ë™ ê°€ëŠ¥
      if (board[front] && board[front][c] === '.') {
        moves.push([front, c]);
        // ì²« ì´ë™ì´ë©´ 2ì¹¸ ê°€ëŠ¥
        if ((isW && r === 6) || (!isW && r === 1)) {
          const doubleFront = r + 2 * dir;
          if (board[doubleFront][c] === '.') {
            moves.push([doubleFront, c]);
          }
        }
      }
      // ëŒ€ê°ì„  ê³µê²©
      for (const dc of [-1, 1]) {
        const nr = r + dir;
        const nc = c + dc;
        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
          const target = board[nr][nc];
          if (target !== '.' && isWhite(target) !== isW) {
            moves.push([nr, nc]);
          }
        }
      }
      break;

    case 'n': // ë‚˜ì´íŠ¸
      [[-2, -1], [-2, 1], [-1, -2], [-1, 2],
       [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => push(r + dr, c + dc));
      break;

    case 'b': // ë¹„ìˆ
      [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => pushSlide(dr, dc));
      break;

    case 'r': // ë£©
      [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => pushSlide(dr, dc));
      break;

    case 'q': // í€¸
      [[1, 0], [-1, 0], [0, 1], [0, -1],
       [1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => pushSlide(dr, dc));
      break;

    case 'k': // í‚¹
  [[1, 0], [-1, 0], [0, 1], [0, -1],
   [1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => push(r + dr, c + dc));
  break;

  }

  return moves;
}

// ìºìŠ¬ë§ ê°€ëŠ¥í•œì§€ í™•ì¸ í•¨ìˆ˜
function canCastle(r, c, side) {
  // side: 'king' or 'queen'
  const isW = isWhite(board[r][c]);
  if (isCheck(isW)) return false; // í˜„ì¬ ì²´í¬ ìƒíƒœë©´ ì•ˆë¨

// í°ìƒ‰ ìºìŠ¬ë§ ê²€ì‚¬ ì˜ˆì‹œ
if (isW) {
  if (side === 'king') {
    if (hasMoved['K_white'] || hasMoved['R_white_h']) return false;
    if (board[7][5] !== '.' || board[7][6] !== '.') return false;
    // ì—¬ê¸°ì„œ true ëŒ€ì‹  !isW ë„˜ê²¨ì•¼ í•¨!
    if (isUnderAttack(7, 5, isW) || isUnderAttack(7, 6, isW)) return false;

    return true;
  } else {
    if (hasMoved['K_white'] || hasMoved['R_white_a']) return false;
    if (board[7][1] !== '.' || board[7][2] !== '.' || board[7][3] !== '.') return false;
    if (isUnderAttack(7, 3, isW) || isUnderAttack(7, 2, isW)) return false;

    return true;
  }

  } else {

if (side === 'king') {
  if (hasMoved['K_black'] || hasMoved['R_black_h']) return false;
  if (board[0][5] !== '.' || board[0][6] !== '.') return false;
if (isUnderAttack(0, 5, isW) || isUnderAttack(0, 6, isW)) return false;
 // ìˆ˜ì •
  return true;
} else {
  if (hasMoved['K_black'] || hasMoved['R_black_a']) return false;
  if (board[0][1] !== '.' || board[0][2] !== '.' || board[0][3] !== '.') return false;
if (isUnderAttack(0, 3, isW) || isUnderAttack(0, 2, isW)) return false; // ìˆ˜ì •
  return true;
}

  }
}

// ì ì´ í•´ë‹¹ ì¹¸ ê³µê²© ì¤‘ì¸ì§€ í™•ì¸ í•¨ìˆ˜ (ì„ì‹œë¡œ ëŒ€ì¶© êµ¬í˜„)
function isUnderAttack(r, c, isW) {
  // isW: ì¹¸ì„ ìˆ˜ë¹„í•˜ëŠ” í¸ì´ ë°±ì¸ì§€ ì•„ë‹Œì§€
  // ì  ê¸°ë¬¼ë“¤ì´ (isW ë°˜ëŒ€) r,c ê³µê²© ê°€ëŠ¥í•œì§€ í™•ì¸ (getBasicMoves ì‚¬ìš©)
  for (let rr = 0; rr < 8; rr++) {
    for (let cc = 0; cc < 8; cc++) {
      if (!board[rr]) continue;
      const ch = board[rr][cc];
      if (ch !== '.' && isWhite(ch) !== isW) {
        const moves = getBasicMoves(rr, cc);
        if (moves.some(([mr, mc]) => mr === r && mc === c)) return true;
      }
    }
  }
  return false;
}



function getLegalMoves(r, c) {
  const basicMoves = getBasicMoves(r, c);
  const legal = [];

  const piece = board[r][c];

  for (const [nr, nc] of basicMoves) {
    const temp = JSON.parse(JSON.stringify(board));
    board[nr][nc] = board[r][c];
    board[r][c] = '.';
    if (!isCheck(isWhite(piece))) legal.push([nr, nc]);


    board = temp;
  }

  // ìºìŠ¬ë§ í›„ë³´ ì¶”ê°€ ...



  // ìºìŠ¬ë§ í›„ë³´ ì¶”ê°€ (í‚¹ì¸ ê²½ìš°)

if (piece.toLowerCase() === 'k') {
  // ì—¬ê¸´ ê¸°ì¡´ì˜ getBasicMoves ì™¸ì— ë”°ë¡œ ì²˜ë¦¬ë˜ë¯€ë¡œ board ìˆ˜ì • ì—†ì´ legalì— ì¶”ê°€
  if (canCastle(r, c, 'king')) {
    legal.push([r, 6]); // ìºìŠ¬ë§ ìœ„ì¹˜ëŠ” ê³ ì •ì„
  }
  if (canCastle(r, c, 'queen')) {
    legal.push([r, 2]);
  }
}

if (piece.toLowerCase() === 'p') {
  const dir = isWhite(piece) ? -1 : 1;
  for (const dc of [-1, 1]) {
    const nr = r + dir;
    const nc = c + dc;
    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
      // ì•™íŒŒìƒ íƒ€ê²Ÿ ì¹¸ê³¼ ê°™ìœ¼ë©´ ì´ë™ í›„ë³´ë¡œ ì¶”ê°€
      if (enPassantTarget && nr === enPassantTarget[0] && nc === enPassantTarget[1]) {
        legal.push([nr, nc]);
      }
    }
  }
}


  console.log(`[${r}, ${c}] legal moves:`, legal); 
  return legal;
}


      let whitePlayerId = null;
let blackPlayerId = null;

function init() {
  get(gameRef).then((snapshot) => {
    if (!snapshot.exists()) {
      // ê²Œì„ì´ ì•„ì§ ì—†ì„ ê²½ìš°: matches/{matchId}ì—ì„œ ë³µì‚¬
      const matchInfoRef = ref(db, `matches/${matchId}`);
      get(matchInfoRef).then((matchSnap) => {
        if (matchSnap.exists()) {
          const matchData = matchSnap.val();

          board = initial.map(row => row.split('')); // ê¸°ë³¸ ë³´ë“œ
          turn = 'white'; // ê¸°ë³¸ í„´
          whitePlayerId = matchData.player1 || null;
          blackPlayerId = matchData.player2 || null;

          // games/{matchId}ì— ì €ì¥
          set(gameRef, {
            board: board.map(row => row.join('')),
            turn,
            whitePlayerId,
            blackPlayerId
          });
          if (whitePlayerId?.uid === myUid) {
  myColor = 'white';
} else if (blackPlayerId?.uid === myUid) {
  myColor = 'black';
}
set(gameRef, {
  board: board.map(row => row.join('')),
  turn,
  whitePlayerId,
  blackPlayerId
}).then(() => {
  drawBoard(); // âœ… ê·¸ í›„ì— í˜¸ì¶œ
});
        } else {
          alert("ë§¤ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.");
          window.location.href = "main.html";
        }
      });
    } else {
// ê²Œì„ ì •ë³´ê°€ ì´ë¯¸ ì¡´ì¬í•  ê²½ìš°
const data = snapshot.val();
whitePlayerId = data.whitePlayerId || null;
blackPlayerId = data.blackPlayerId || null;
board = data.board.map(row => row.split(''));
turn = data.turn;

// ğŸ’¥ myColor ì„¤ì • ëˆ„ë½!
if (whitePlayerId?.uid === myUid) {
  myColor = 'white';
} else if (blackPlayerId?.uid === myUid) {
  myColor = 'black';
}

drawBoard();
    }
  });
}

 function isCheckMate(isW) {
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = board[r][c];
      if (piece !== '.' && isWhite(piece) === isW) {
        const moves = getLegalMoves(r, c);
        if (moves.length > 0) {
          return false; // í•œ ìˆ˜ë¼ë„ í”¼í•  ìˆ˜ ìˆìœ¼ë©´ ì²´í¬ë©”ì´íŠ¸ ì•„ë‹˜
        }
      }
    }
  }
  return isCheck(isW); // ì²´í¬ ìƒíƒœì´ë©° í”¼í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ì²´í¬ë©”ì´íŠ¸
}
   

function animateMove(fromRow, fromCol, toRow, toCol, callback) {
  const fromCell = document.querySelector(`.cell[data-row="${fromRow}"][data-col="${fromCol}"]`);
  const toCell = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
  const pieceImg = fromCell.querySelector('img');
  if (!pieceImg || !toCell) {
    callback();
    return;
  }

  const clone = pieceImg.cloneNode();
  const boardRect = boardElement.getBoundingClientRect();
  const startRect = fromCell.getBoundingClientRect();
  const endRect = toCell.getBoundingClientRect();

  const deltaX = endRect.left - startRect.left;
  const deltaY = endRect.top - startRect.top;

  clone.style.position = 'absolute';
  clone.style.left = `${startRect.left - boardRect.left}px`;
  clone.style.top = `${startRect.top - boardRect.top}px`;
  clone.style.width = '80px';
  clone.style.height = '80px';
  clone.style.transition = 'transform 0.3s ease';
  clone.style.pointerEvents = 'none';
  clone.style.zIndex = 100;
  clone.style.transform = 'translate(0, 0)';

  boardElement.appendChild(clone);

  requestAnimationFrame(() => {
    clone.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
  });

  setTimeout(() => {
    clone.remove();
    callback(); // ì´ ì•ˆì—ì„œ drawBoard() ì‹¤í–‰
  }, 300);
}



    
  </script>
</body>
</html>
